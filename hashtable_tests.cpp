// Copyright 2016
#include <iostream>
#include <cstdlib>
#include <ctime>
#include <string>
#include <ostream>
#include <vector>
#include <unordered_map>
#include <utility>
#include <memory>
#include <limits>
#include <fstream>


#include <esr/hashtest.hpp>
#include <esr/hashtable.hpp>



#ifdef __GNUC__
#define PRETTY_PRINT() do {std::cout << __PRETTY_FUNCTION__;} while (0)
#else
#define PRETTY_PRINT()
#endif

// Functional esr::CorrectnessTest
// Load Testing
// Stress Testing
// Performance Testing

using std::shared_ptr;

namespace esr_test {

// #ifdef ENABLE_INT_INT_BASIC_TESTS

template <>
bool InsertionRetrievalTest<int, int>::make_expected_hashtable() {
  int key, value;
  int up = 2*intput_size();
  for (key = 0, value = up; key < up; ++key, --value) {
    auto key_value = std::make_pair(key, value);
    bool success = false;
    if (key % 2 == 0)
      success = m_positive_table.insert(key_value).second;
    else
      success = m_negative_table.insert(key_value).second;
    if (!success) {
      std::cout << __ESR_PRETTY_FUNCTION__ << ' '
                << "failed to insert key = " << key << ", "
                << "value = " << value << ". "
                << std::flush;
      return false;
    }
  }
  return true;
}

// Add unique_file for RAII
template <>
bool InsertionRetrievalTest<std::string, int>::make_expected_hashtable() {
  // unique_strings.txt: generated by random.org at https://www.random.org/strings
  std::ifstream file("unique_strings.txt");
  if (!file.is_open()) {
    std::cerr << "test error: couldn't open file \"hashtable_tests.cpp\"\n";
    return false;
  }

  for (int value = 0; file.good(); ++value) {
    std::string key;
    file >> key;
    auto key_value = std::make_pair(key, value);
    bool success = false;
    if (value % 2 == 0)
      success = m_positive_table.insert(key_value).second;
    else
      success = m_negative_table.insert(key_value).second;

    if (!success) {
      std::cout << __ESR_PRETTY_FUNCTION__ << ' '
                << "failed to insert key = " << key << ", "
                << "value = " << value << ". "
                << std::flush;
      return false;
    }
  }
  file.close();
  return true;
}

template <>
bool InsertionRetrievalTest<int, std::string>::make_expected_hashtable() {
  // unique_strings.txt: generated by random.org at https://www.random.org/strings
  std::ifstream file("unique_strings.txt");
  if (!file.is_open()) {
    std::cerr << "test error: couldn't open file \"hashtable_tests.cpp\"\n";
    return false;
  }

  for (int key = 0; file.good(); ++key) {
    std::string value;
    file >> value;
    auto key_value = std::make_pair(key, value);
    bool success = false;
    if (key % 2 == 0)
      success = m_positive_table.insert(key_value).second;
    else
      success = m_negative_table.insert(key_value).second;

    if (!success) {
      std::cout << __ESR_PRETTY_FUNCTION__ << ' '
                << "failed to insert key = " << key << ", "
                << "value = " << value << ". "
                << std::flush;
      return false;
    }
  }
  file.close();
  return true;
}

template <>
bool InsertionRetrievalTest<std::string, std::string>::
make_expected_hashtable() {
  // unique_strings.txt: generated by random.org at https://www.random.org/strings
  std::ifstream file("unique_strings.txt");
  if (!file.is_open()) {
    std::cerr << "test error: couldn't open file \"hashtable_tests.cpp\"\n";
    return false;
  }

  for (int i = 0; file.good(); ++i) {
    std::string key;
    std::string value;
    file >> key;
    value = key;
    auto key_value = std::make_pair(key, value);
    bool success = false;
    if (i % 2 == 0)
      success = m_positive_table.insert(key_value).second;
    else
      success = m_negative_table.insert(key_value).second;

    if (!success) {
      std::cout << __ESR_PRETTY_FUNCTION__ << ' '
                << "failed to insert key = " << key << ", "
                << "value = " << value << ". "
                << std::flush;
      return false;
    }
  }
  file.close();
  return true;
}

template <>
bool InsertionRetrievalTest<bool, int>::make_expected_hashtable() {
  bool key_positive = true;
  bool key_negative = false;
  int value_positive = 8;
  int value_negative = 7;

  auto key_value_positive = std::make_pair(key_positive, value_positive);
  auto key_value_negative = std::make_pair(key_negative, value_negative);

  bool success_positive = m_positive_table.insert(key_value_positive).second;
  if (!success_positive) {
        std::cout << __ESR_PRETTY_FUNCTION__ << ' '
                  << "failed to insert key = " << key_positive << ", "
                  << "value = " << value_positive << ". "
                  << std::flush;
        return false;
  }

  bool success_negative = m_negative_table.insert(key_value_negative).second;
  if (!success_negative) {
        std::cout << __ESR_PRETTY_FUNCTION__ << ' '
                  << "failed to insert key = " << key_negative << ", "
                  << "value = " << value_negative << ". "
                  << std::flush;
        return false;
  }
  return true;
}

template <>
bool InsertionRetrievalTest<int, bool>::make_expected_hashtable() {
  int key;
  bool value;
  int up = 2*intput_size();
  for (key = 0, value = false; key < up; ++key, value = !value) {
    auto key_value = std::make_pair(key, value);
    bool success = false;
    if (key % 2 == 0)
      success = m_positive_table.insert(key_value).second;
    else
      success = m_negative_table.insert(key_value).second;
    if (!success) {
      std::cout << __ESR_PRETTY_FUNCTION__ << ' '
                << "failed to insert key = " << key << ", "
                << "value = " << value << ". "
                << std::flush;
      return false;
    }
  }
  return true;
}

template <>
bool InsertionRetrievalTest<bool, std::string>::make_expected_hashtable() {
  bool key_positive = true;
  bool key_negative = false;
  std::string value_positive = "love";
  std::string value_negative = "hate";

  auto key_value_positive = std::make_pair(key_positive, value_positive);
  auto key_value_negative = std::make_pair(key_negative, value_negative);

  bool success_positive = m_positive_table.insert(key_value_positive).second;
  if (!success_positive) {
        std::cout << __ESR_PRETTY_FUNCTION__ << ' '
                  << "failed to insert key = " << key_positive << ", "
                  << "value = " << value_positive << ". "
                  << std::flush;
        return false;
  }

  bool success_negative = m_negative_table.insert(key_value_negative).second;
  if (!success_negative) {
        std::cout << __ESR_PRETTY_FUNCTION__ << ' '
                  << "failed to insert key = " << key_negative << ", "
                  << "value = " << value_negative << ". "
                  << std::flush;
        return false;
  }
  return true;
}

// Add unique_file for RAII
template <>
bool InsertionRetrievalTest<std::string, bool>::make_expected_hashtable() {
  // unique_strings.txt: generated by random.org at https://www.random.org/strings
  std::ifstream file("unique_strings.txt");
  if (!file.is_open()) {
    std::cerr << "test error: couldn't open file \"hashtable_tests.cpp\"\n";
    return false;
  }

  for (int i = 0; file.good(); ++i) {
    std::string key;
    bool value;
    file >> key;
    value = i % 2;
    auto key_value = std::make_pair(key, value);
    bool success = false;
    if (value)
      success = m_positive_table.insert(key_value).second;
    else
      success = m_negative_table.insert(key_value).second;

    if (!success) {
      std::cout << __ESR_PRETTY_FUNCTION__ << ' '
                << "failed to insert key = " << key << ", "
                << "value = " << value << ". "
                << std::flush;
      return false;
    }
  }
  file.close();
  return true;
}

template <>
bool InsertionRetrievalTest<bool, bool>::make_expected_hashtable() {
  bool key_positive = true;
  bool key_negative = false;
  bool value_positive = false;
  bool value_negative = false;

  auto key_value_positive = std::make_pair(key_positive, value_positive);
  auto key_value_negative = std::make_pair(key_negative, value_negative);

  bool success_positive = m_positive_table.insert(key_value_positive).second;
  if (!success_positive) {
        std::cout << __ESR_PRETTY_FUNCTION__ << ' '
                  << "failed to insert key = " << key_positive << ", "
                  << "value = " << value_positive << ". "
                  << std::flush;
        return false;
  }

  bool success_negative = m_negative_table.insert(key_value_negative).second;
  if (!success_negative) {
        std::cout << __ESR_PRETTY_FUNCTION__ << ' '
                  << "failed to insert key = " << key_negative << ", "
                  << "value = " << value_negative << ". "
                  << std::flush;
        return false;
  }
  return true;
}

}  // namespace esr_test


int main() {
  std::vector<shared_ptr<esr_test::CorrectnessTest>> correctness_tests;
  /*
#ifdef ENABLE_INT_INT_TESTS

#ifdef ENABLE_INT_INT_BASIC_TESTS
  */

////////////////////////////////////////////////////////////////////////////////
// Insertions and Retrievals
////////////////////////////////////////////////////////////////////////////////
  correctness_tests.push_back(
      shared_ptr<esr_test::InsertionRetrievalTest<int, int>>
      (new esr_test::InsertionRetrievalTest<int, int>(16, "<int, int>")));

  correctness_tests.push_back(
      shared_ptr<esr_test::InsertionRetrievalTest<std::string, int>>
      (new esr_test::InsertionRetrievalTest<std::string, int>
       (16, "<string, int>")));

  correctness_tests.push_back(
      shared_ptr<esr_test::InsertionRetrievalTest<int, std::string>>
      (new esr_test::InsertionRetrievalTest<int, std::string>
       (16, "<int, string>")));

  correctness_tests.push_back(
      shared_ptr<esr_test::InsertionRetrievalTest<std::string, std::string>>
      (new esr_test::InsertionRetrievalTest<std::string, std::string>
       (16, "<string, string>")));

  correctness_tests.push_back(
      shared_ptr<esr_test::InsertionRetrievalTest<bool, int>>
      (new esr_test::InsertionRetrievalTest<bool, int>(1, "<bool, int>")));

  correctness_tests.push_back(
      shared_ptr<esr_test::InsertionRetrievalTest<int, bool>>
      (new esr_test::InsertionRetrievalTest<int, bool>(16, "<int, bool>")));

  correctness_tests.push_back(
      shared_ptr<esr_test::InsertionRetrievalTest<bool, std::string>>
      (new esr_test::InsertionRetrievalTest<bool, std::string>
       (1, "<bool, string>")));

  correctness_tests.push_back(
      shared_ptr<esr_test::InsertionRetrievalTest<std::string, bool>>
      (new esr_test::InsertionRetrievalTest<std::string, bool>
       (16, "<string, bool>")));

  correctness_tests.push_back(
      shared_ptr<esr_test::InsertionRetrievalTest<bool, bool>>
      (new esr_test::InsertionRetrievalTest<bool, bool>(1, "<bool, bool>")));

////////////////////////////////////////////////////////////////////////////////
// Constructors and assignments
////////////////////////////////////////////////////////////////////////////////
  correctness_tests.push_back(
      shared_ptr<esr_test::CtorAssignmentTest<int, int>>
      (new esr_test::CtorAssignmentTest<int, int>(16, "<int, int>")));

////////////////////////////////////////////////////////////////////////////////
// Deletions
////////////////////////////////////////////////////////////////////////////////
#if 0
  correctness_tests.push_back(
      shared_ptr<esr_test::DeletionTest<int, int>>
      (new esr_test::DeletionTest<int, int>(16, "<int, int>")));

  correctness_tests.push_back(
      shared_ptr<esr_test::InsertionRetrievalTest<std::string, int>>
      (new esr_test::DeletionTest<std::string, int>
       (16, "<string, int>")));

  correctness_tests.push_back(
      shared_ptr<esr_test::InsertionRetrievalTest<int, std::string>>
      (new esr_test::DeletionTest<int, std::string>
       (16, "<int, string>")));

  correctness_tests.push_back(
      shared_ptr<esr_test::InsertionRetrievalTest<std::string, std::string>>
      (new esr_test::DeletionTest<std::string, std::string>
       (16, "<string, string>")));

  correctness_tests.push_back(
      shared_ptr<esr_test::DeletionTest<bool, int>>
      (new esr_test::DeletionTest<bool, int>(1, "<bool, int>")));

  correctness_tests.push_back(
      shared_ptr<esr_test::DeletionTest<int, bool>>
      (new esr_test::DeletionTest<int, bool>(16, "<int, bool>")));

  correctness_tests.push_back(
      shared_ptr<esr_test::DeletionTest<bool, std::string>>
      (new esr_test::DeletionTest<bool, std::string>
       (1, "<bool, string>")));

  correctness_tests.push_back(
      shared_ptr<esr_test::DeletionTest<std::string, bool>>
      (new esr_test::DeletionTest<std::string, bool>
       (16, "<string, bool>")));

  correctness_tests.push_back(
      shared_ptr<esr_test::DeletionTest<bool, bool>>
      (new esr_test::DeletionTest<bool, bool>(1, "<bool, bool>")));

#endif

  for (auto test : correctness_tests) {
    std::cout << test->name()
              << "{size=" << test->intput_size() << "} "
              << test->description() << " : "
              << std::flush;

    if (!test->make_expected_hashtable()) {
      std::cout << "Failed to make expected hash table. "
                << "[SKIPPED]\n"
                << std::flush;
      continue;
    }
    std::cout<< (test->run() ? "[PASSED]" : "[FAILED]") << '\n';
  }


















  
                        /*
  esr::CorrectnessTest.push_back(shared_ptr<test::DeletionTest<int, int>>
                        (new test::DeletionTest<int, int>(65535)));


  // Small and Large tests
  esr::CorrectnessTest.push_back(shared_ptr<test::DeletionTest<int, int>>
                        (new test::DeletionTest<int, int>(1)));


  esr::CorrectnessTest.push_back(shared_ptr<test::DeletionTestRange>
                        (new test::DeletionTestRange(
                            std::numeric_limits<int>::max() - 4096,
                            std::numeric_limits<int>::max(), "DeletionTestMaxInt")));

#endif  // ENABLE_INT_INT_BASIC_TESTS

#ifdef ENABLE_INT_INT_HAVY_TEST
  // Havy load tests
  for (int i = std::numeric_limits<int>::max() / 100; i > 1; i /= 2) {
    esr::CorrectnessTest.push_back(shared_ptr<test::DeletionTest<int, int>>
                          (new test::DeletionTest<int, int>(i, "DeletionTestHavyLoad")));
  }
#endif  // ENABLE_INT_INT_HAVY_TEST

#ifdef ENABLE_INT_INT_RANDOM_ACCESS_TEST
  // Random access test
  esr::CorrectnessTest.push_back(shared_ptr<test::RandomAdd_DefiniteGet<int, int>>
                        (new test::RandomAdd_DefiniteGet<int, int>(8192)));

  esr::CorrectnessTest.push_back(shared_ptr<test::DefiniteAdd_RandomGet<int, int>>
                        (new test::DefiniteAdd_RandomGet<int, int>(8192)));

#endif  // ENABLE_INT_INT_RANDOM_ACCESS_TEST

#endif  // ENABLE_INT_INT_TESTS
  */
  /*
  esr::CorrectnessTest.push_back(shared_ptr<test::DeletionTest<std::string, int>>
                        (new test::DeletionTest<std::string, int>
                         (1024, "DeletionTestStringInt")));
  */



  

  
  /*
  esr::CorrectnessTest.push_back(shared_ptr<test::DeletionTestRange<int, int>>
                        (new test::DeletionTest<int, int>(
                            std::numeric_limits<int>::max())));
  */



  /*
  esr::CorrectnessTest.push_back(
      shared_ptr<test::RandomDeletionTest<std::string, int>>
      (new test::RandomDeletionTest<std::string, int>("RandomDeletionTest")));

  esr::CorrectnessTest.push_back(
      shared_ptr<test::RandomDeletionTest<std::string, int>>
      (new test::RandomDeletionTest<std::string, int>("RandomDeletionTest", 2048)));
  */

  /*
    if (shared_ptr<test::DeletionTestRange> agr_test =
         std::static_pointer_cast<test::DeletionTestRange>(test))
      std::cout << '[' << agr_test->low() << ':'
                <<  agr_test->high() << ']' << " ";
    else
    */
    // std::cout << '[' << test->intput_size() <<  ']' << "...";

  /*
  esr::Hashtable<std::string, std::string> shash;
  shash.add("fima", "where are you?");
  const std::string* s = shash.get("fima");
  std::cout << *s << '\n';
  std:: cout << shash << '\n';
  */
  return 0;
}

#if 0

class DeletionTestRange : public DeletionTest<int, int>  {
 public:
  explicit DeletionTestRange(int low = 0, int high = 1024,
                       const std::string & name = "DeletionTestRange") :
      DeletionTest(high - low + 1, name),
      m_low(low),
      m_high(high) {}
  virtual ~DeletionTestRange() { /* std::cout << "DeletionTestRange dtor\n"; */ }
  int low() const { return m_low; }
  int high() const { return m_high; }

 protected:
  virtual bool make_expected_hashtable() {
    int key, value;
    for (key = m_low, value = m_low; key != m_high; ++key, ++value) {
      bool r_success = m_test_table.add(key , value);
      bool e_success = m_positive_table.insert(std::make_pair(key, value)).second;
      if (r_success != e_success) {
        PRETTY_PRINT();
        std::cout << "Adding to Htable "
                  << (r_success ? "succeeded" : "omitted")
                  << " , adding to unordered_map "
                  << (e_success ? "succeeded" : "omitted") << '\n';
        return false;
      }
    }
    m_test_table.add(key, value);
    m_positive_table.insert(std::make_pair(key, value));
  }

 private:
  int m_low;
  int m_high;
};
// #endif  // ENABLE_INT_INT_BASIC_TESTS

template <typename K, typename V>
class RandomAdd_DefiniteGet: public DeletionTest<K, V>{
 public:
  explicit RandomAdd_DefiniteGet(int count = 1024,
                        const std::string & name = "RandomAdd_DefiniteGet") :
      DeletionTest<K, V>(count, name),
      m_insertions_succeed(0),
      m_insertions_omitted(0) {std::srand(std::time(0)); }
  virtual ~RandomAdd_DefiniteGet() { /* std::cout << "DeletionTest dtor\n"; */ }

 protected:
  bool make_expected_hashtable();

 private:
  size_t m_insertions_succeed;
  size_t m_insertions_omitted;
};

template <>
bool RandomAdd_DefiniteGet<int, int>::make_expected_hashtable() {
  for (int i = 0; i < intput_size(); ++i) {
    int key = std::rand();
    int val = std::rand();
    bool r_success = m_test_table.add(key , val);
    bool e_success = m_positive_table.insert(std::make_pair(key, val)).second;
    if (r_success != e_success) {
      PRETTY_PRINT();
      std::cout << "Adding to Htable "
                << (r_success ? "succeeded" : "omitted")
                << " , adding to unordered_map "
                << (e_success ? "succeeded" : "omitted") << '\n';
      return false;
    }
    r_success ? m_insertions_succeed++ : m_insertions_omitted++;
  }
  // std::cout << m_test_table << '\n';
  return true;
}

template <typename K, typename V>
class DefiniteAdd_RandomGet: public DeletionTest<K, V>{
 public:
  explicit DefiniteAdd_RandomGet(int count = 1024,
                        const std::string & name = "DefiniteAdd_RandomGet") :
      DeletionTest<K, V>(count, name),
      m_retrievals_succeed(0),
      m_retrievals_omitted(0) {std::srand(std::time(0)); }
  virtual ~DefiniteAdd_RandomGet() {}
  virtual bool run();
 protected:
  //  bool make_expected_hashtable();

 private:
  size_t m_retrievals_succeed;
  size_t m_retrievals_omitted;
};

template <>
bool DefiniteAdd_RandomGet<int, int>::run() {
    if ( !make_expected_hashtable() )
      return false;

    for (int i = 0; i < intput_size(); ++i) {
      int key = std::rand();
      auto r_found = m_test_table.get(key);
      bool r_success = r_found != nullptr ? true : false;
      auto e_found = m_positive_table.find(key);
      bool e_success = e_found != m_positive_table.end() ? true : false;
      if (r_success != e_success) {
        PRETTY_PRINT();
        std::cout << "Retrieval from Htable "
                  << (r_success ? "succeeded" : "omitted")
                  << " , retrieval from unordered_map "
                  << (e_success ? "succeeded" : "omitted") << '\n';
        return false;
      }

      if ( !r_success ) {
        m_retrievals_omitted++;
        return true;
      }
      m_retrievals_succeed++;
      int r_value = *r_found;
      int e_value = e_found->second;
      if (r_value != e_value) {
        PRETTY_PRINT();
        std::cout << "Htable's value = " << r_value
                  << " and unordered_map's value = " << e_value
                  << " are different for key = " << key << '\n';
      }
      return true;
    }
    // std::cout << m_test_table << '\n';
    return false;
}
// #endif  // ENABLE_INT_INT_RANDOM_ACCESS_TEST
// #endif  // ENABLE_INT_INT_TESTS
#endif
