// Copyright 2016
#include <iostream>
#include <cstdlib>
#include <ctime>
#include <string>
#include <ostream>
#include <vector>
#include <unordered_map>
#include <utility>
#include <memory>
#include <limits>
#include <fstream>

#include <esr/hashtest.hpp>
#include <esr/hashtable.hpp>


using std::shared_ptr;

namespace esr_test {

template <>
bool InsertionRetrievalTest<int, int>::make_expected_hashtable() {
  int key, value;
  int up = 2*intput_size();
  for (key = 0, value = up; key < up; ++key, --value) {
    auto key_value = std::make_pair(key, value);
    bool success = false;
    if (key % 2 == 0)
      success = m_positive_table.insert(key_value).second;
    else
      success = m_negative_table.insert(key_value).second;
    if (!success) {
      std::cout << __ESR_PRETTY_FUNCTION__ << ' '
                << "failed to insert key = " << key << ", "
                << "value = " << value << ". "
                << std::flush;
      return false;
    }
  }
  return true;
}

template <>
bool InsertionRetrievalTest<std::string, int>::make_expected_hashtable() {
  // unique_strings.txt: generated by random.org at https://www.random.org/strings
  std::ifstream file("./data/unique_strings.txt");
  if (!file.is_open()) {
    std::cerr << "test error: couldn't open file \"unique_strings.txt\"\n";
    return false;
  }

  for (int value = 0; file.good(); ++value) {
    std::string key;
    file >> key;
    auto key_value = std::make_pair(key, value);
    bool success = false;
    if (value % 2 == 0)
      success = m_positive_table.insert(key_value).second;
    else
      success = m_negative_table.insert(key_value).second;

    if (!success) {
      std::cout << __ESR_PRETTY_FUNCTION__ << ' '
                << "failed to insert key = " << key << ", "
                << "value = " << value << ". "
                << std::flush;
      file.close();
      return false;
    }
  }
  file.close();
  return true;
}

template <>
bool InsertionRetrievalTest<int, std::string>::make_expected_hashtable() {
  // unique_strings.txt: generated by random.org at https://www.random.org/strings
  std::ifstream file("./data/unique_strings.txt");

  if (!file.is_open()) {
    std::cerr << "test error: couldn't open file \"unique_strings.txt\"\n";
    return false;
  }

  for (int key = 0; file.good(); ++key) {
    std::string value;
    file >> value;
    auto key_value = std::make_pair(key, value);
    bool success = false;
    if (key % 2 == 0)
      success = m_positive_table.insert(key_value).second;
    else
      success = m_negative_table.insert(key_value).second;

    if (!success) {
      std::cout << __ESR_PRETTY_FUNCTION__ << ' '
                << "failed to insert key = " << key << ", "
                << "value = " << value << ". "
                << std::flush;
      file.close();
      return false;
    }
  }
  file.close();
  return true;
}

template <>
bool InsertionRetrievalTest<std::string,
                            std::string>:: make_expected_hashtable() {
  // unique_strings.txt: generated by random.org at https://www.random.org/strings

  std::ifstream file("./data/unique_strings.txt");
  if (!file.is_open()) {
    std::cerr << "test error: couldn't open file \"unique_strings.txt\"\n";
    return false;
  }

  for (int i = 0; file.good(); ++i) {
    std::string key;
    std::string value;
    file >> key;
    value = key;
    auto key_value = std::make_pair(key, value);
    bool success = false;
    if (i % 2 == 0)
      success = m_positive_table.insert(key_value).second;
    else
      success = m_negative_table.insert(key_value).second;

    if (!success) {
      std::cout << __ESR_PRETTY_FUNCTION__ << ' '
                << "failed to insert key = " << key << ", "
                << "value = " << value << ". "
                << std::flush;
      file.close();
      return false;
    }
  }
  file.close();
  return true;
}

template <>
bool InsertionRetrievalTest<bool, int>::make_expected_hashtable() {
  bool key_positive = true;
  bool key_negative = false;
  int value_positive = 8;
  int value_negative = 7;

  auto key_value_positive = std::make_pair(key_positive, value_positive);
  auto key_value_negative = std::make_pair(key_negative, value_negative);

  bool success_positive = m_positive_table.insert(key_value_positive).second;
  if (!success_positive) {
        std::cout << __ESR_PRETTY_FUNCTION__ << ' '
                  << "failed to insert key = " << key_positive << ", "
                  << "value = " << value_positive << ". "
                  << std::flush;
        return false;
  }

  bool success_negative = m_negative_table.insert(key_value_negative).second;
  if (!success_negative) {
        std::cout << __ESR_PRETTY_FUNCTION__ << ' '
                  << "failed to insert key = " << key_negative << ", "
                  << "value = " << value_negative << ". "
                  << std::flush;
        return false;
  }
  return true;
}

template <>
bool InsertionRetrievalTest<int, bool>::make_expected_hashtable() {
  int key;
  bool value;
  int up = 2*intput_size();
  for (key = 0, value = false; key < up; ++key, value = !value) {
    auto key_value = std::make_pair(key, value);
    bool success = false;
    if (key % 2 == 0)
      success = m_positive_table.insert(key_value).second;
    else
      success = m_negative_table.insert(key_value).second;
    if (!success) {
      std::cout << __ESR_PRETTY_FUNCTION__ << ' '
                << "failed to insert key = " << key << ", "
                << "value = " << value << ". "
                << std::flush;
      return false;
    }
  }
  return true;
}

template <>
bool InsertionRetrievalTest<bool, std::string>::make_expected_hashtable() {
  bool key_positive = true;
  bool key_negative = false;
  std::string value_positive = "love";
  std::string value_negative = "hate";

  auto key_value_positive = std::make_pair(key_positive, value_positive);
  auto key_value_negative = std::make_pair(key_negative, value_negative);

  bool success_positive = m_positive_table.insert(key_value_positive).second;
  if (!success_positive) {
        std::cout << __ESR_PRETTY_FUNCTION__ << ' '
                  << "failed to insert key = " << key_positive << ", "
                  << "value = " << value_positive << ". "
                  << std::flush;
        return false;
  }

  bool success_negative = m_negative_table.insert(key_value_negative).second;
  if (!success_negative) {
        std::cout << __ESR_PRETTY_FUNCTION__ << ' '
                  << "failed to insert key = " << key_negative << ", "
                  << "value = " << value_negative << ". "
                  << std::flush;
        return false;
  }
  return true;
}

template <>
bool InsertionRetrievalTest<std::string, bool>::make_expected_hashtable() {
  // unique_strings.txt: generated by random.org at https://www.random.org/strings
  std::ifstream file("./data/unique_strings.txt");
  if (!file.is_open()) {
    std::cerr << "test error: couldn't open file \"unique_strings.txt\"\n";
    return false;
  }
  for (int i = 0; file.good(); ++i) {
    std::string key;
    bool value;
    file >> key;
    value = i % 2;
    auto key_value = std::make_pair(key, value);
    bool success = false;
    if (value)
      success = m_positive_table.insert(key_value).second;
    else
      success = m_negative_table.insert(key_value).second;

    if (!success) {
      std::cout << __ESR_PRETTY_FUNCTION__ << ' '
                << "failed to insert key = " << key << ", "
                << "value = " << value << ". "
                << std::flush;

      file.close();
      return false;
    }
  }
  file.close();
  return true;
}

template <>
bool InsertionRetrievalTest<bool, bool>::make_expected_hashtable() {
  bool key_positive = true;
  bool key_negative = false;
  bool value_positive = false;
  bool value_negative = false;

  auto key_value_positive = std::make_pair(key_positive, value_positive);
  auto key_value_negative = std::make_pair(key_negative, value_negative);

  bool success_positive = m_positive_table.insert(key_value_positive).second;
  if (!success_positive) {
        std::cout << __ESR_PRETTY_FUNCTION__ << ' '
                  << "failed to insert key = " << key_positive << ", "
                  << "value = " << value_positive << ". "
                  << std::flush;
        return false;
  }

  bool success_negative = m_negative_table.insert(key_value_negative).second;
  if (!success_negative) {
        std::cout << __ESR_PRETTY_FUNCTION__ << ' '
                  << "failed to insert key = " << key_negative << ", "
                  << "value = " << value_negative << ". "
                  << std::flush;
        return false;
  }
  return true;
}

}  // namespace esr_test

const size_t kIntegerKeysCount = (1024*1024);
const size_t kStringKeysCount = 10000;

int main() {
  std::vector<shared_ptr<esr_test::CorrectnessTest>> correctness_tests;
////////////////////////////////////////////////////////////////////////////////
// Insertions and Retrievals
////////////////////////////////////////////////////////////////////////////////
  correctness_tests.push_back(
      shared_ptr<esr_test::InsertionRetrievalTest<int, int>>
      (new esr_test::InsertionRetrievalTest<int, int>
       (kIntegerKeysCount, "<int, int>")));

  correctness_tests.push_back(
      shared_ptr<esr_test::InsertionRetrievalTest<std::string, int>>
      (new esr_test::InsertionRetrievalTest<std::string, int>
       (kStringKeysCount, "<string, int>")));

  correctness_tests.push_back(
      shared_ptr<esr_test::InsertionRetrievalTest<int, std::string>>
      (new esr_test::InsertionRetrievalTest<int, std::string>
       (kIntegerKeysCount, "<int, string>")));

  correctness_tests.push_back(
      shared_ptr<esr_test::InsertionRetrievalTest<std::string, std::string>>
      (new esr_test::InsertionRetrievalTest<std::string, std::string>
       (kStringKeysCount, "<string, string>")));

  correctness_tests.push_back(
      shared_ptr<esr_test::InsertionRetrievalTest<bool, int>>
      (new esr_test::InsertionRetrievalTest<bool, int>(2, "<bool, int>")));

  correctness_tests.push_back(
      shared_ptr<esr_test::InsertionRetrievalTest<int, bool>>
      (new esr_test::InsertionRetrievalTest<int, bool>
       (kIntegerKeysCount, "<int, bool>")));

  correctness_tests.push_back(
      shared_ptr<esr_test::InsertionRetrievalTest<bool, std::string>>
      (new esr_test::InsertionRetrievalTest<bool, std::string>
       (2, "<bool, string>")));

  correctness_tests.push_back(
      shared_ptr<esr_test::InsertionRetrievalTest<std::string, bool>>
      (new esr_test::InsertionRetrievalTest<std::string, bool>
       (kStringKeysCount, "<string, bool>")));

  correctness_tests.push_back(
      shared_ptr<esr_test::InsertionRetrievalTest<bool, bool>>
      (new esr_test::InsertionRetrievalTest<bool, bool>(1, "<bool, bool>")));

////////////////////////////////////////////////////////////////////////////////
// Copy and assignments
////////////////////////////////////////////////////////////////////////////////
  correctness_tests.push_back(
      shared_ptr<esr_test::CopyAssignmentTest<int, int>>
      (new esr_test::CopyAssignmentTest<int, int>
       (kIntegerKeysCount, "<int, int>")));

  correctness_tests.push_back(
      shared_ptr<esr_test::CopyAssignmentTest<std::string, int>>
      (new esr_test::CopyAssignmentTest<std::string, int>
       (kStringKeysCount, "<string, int>")));

  correctness_tests.push_back(
      shared_ptr<esr_test::CopyAssignmentTest<int, std::string>>
      (new esr_test::CopyAssignmentTest<int, std::string>
       (kIntegerKeysCount, "<int, string>")));

  correctness_tests.push_back(
      shared_ptr<esr_test::CopyAssignmentTest<std::string, std::string>>
      (new esr_test::CopyAssignmentTest<std::string, std::string>
       (kStringKeysCount, "<string, string>")));

  correctness_tests.push_back(
      shared_ptr<esr_test::CopyAssignmentTest<bool, int>>
      (new esr_test::CopyAssignmentTest<bool, int>(2, "<bool, int>")));

  correctness_tests.push_back(
      shared_ptr<esr_test::CopyAssignmentTest<int, bool>>
      (new esr_test::CopyAssignmentTest<int, bool>
       (kIntegerKeysCount, "<int, bool>")));

  correctness_tests.push_back(
      shared_ptr<esr_test::CopyAssignmentTest<bool, std::string>>
      (new esr_test::CopyAssignmentTest<bool, std::string>
       (2, "<bool, string>")));

  correctness_tests.push_back(
      shared_ptr<esr_test::CopyAssignmentTest<std::string, bool>>
      (new esr_test::CopyAssignmentTest<std::string, bool>
       (kStringKeysCount, "<string, bool>")));

  correctness_tests.push_back(
      shared_ptr<esr_test::CopyAssignmentTest<bool, bool>>
      (new esr_test::CopyAssignmentTest<bool, bool>(2, "<bool, bool>")));

////////////////////////////////////////////////////////////////////////////////
// Deletions
////////////////////////////////////////////////////////////////////////////////
  correctness_tests.push_back(
      shared_ptr<esr_test::DeletionTest<int, int>>
      (new esr_test::DeletionTest<int, int>(kIntegerKeysCount, "<int, int>")));

  correctness_tests.push_back(
      shared_ptr<esr_test::InsertionRetrievalTest<std::string, int>>
      (new esr_test::DeletionTest<std::string, int>
       (kStringKeysCount, "<string, int>")));

  correctness_tests.push_back(
      shared_ptr<esr_test::InsertionRetrievalTest<int, std::string>>
      (new esr_test::DeletionTest<int, std::string>
       (kIntegerKeysCount, "<int, string>")));

  correctness_tests.push_back(
      shared_ptr<esr_test::InsertionRetrievalTest<std::string, std::string>>
      (new esr_test::DeletionTest<std::string, std::string>
       (kStringKeysCount, "<string, string>")));

  correctness_tests.push_back(
      shared_ptr<esr_test::DeletionTest<bool, int>>
      (new esr_test::DeletionTest<bool, int>(2, "<bool, int>")));

  correctness_tests.push_back(
      shared_ptr<esr_test::DeletionTest<int, bool>>
      (new esr_test::DeletionTest<int, bool>
       (kIntegerKeysCount, "<int, bool>")));

  correctness_tests.push_back(
      shared_ptr<esr_test::DeletionTest<bool, std::string>>
      (new esr_test::DeletionTest<bool, std::string>
       (2, "<bool, string>")));

  correctness_tests.push_back(
      shared_ptr<esr_test::DeletionTest<std::string, bool>>
      (new esr_test::DeletionTest<std::string, bool>
       (kStringKeysCount, "<string, bool>")));

  correctness_tests.push_back(
      shared_ptr<esr_test::DeletionTest<bool, bool>>
      (new esr_test::DeletionTest<bool, bool>(2, "<bool, bool>")));

  for (auto test : correctness_tests) {
    std::cout << test->name()
              << "{size=" << test->intput_size() << "} "
              << test->description() << " : "
              << std::flush;

    if (!test->make_expected_hashtable()) {
      std::cout << "Failed to make expected hash table. "
                << "[SKIPPED]\n"
                << std::flush;
      continue;
    }
    std::cout<< (test->run() ? "[PASSED]" : "[FAILED]") << '\n';
  }
  return 0;
}
